import numpy as np
from sklearn.metrics import mutual_info_score

# Load joint motion data representation
npy_file_path = '/home/Student/s4582342/LSE/test_data_joint_motion.npy'
data = np.load(npy_file_path)

# Define the number of bins parameter
num_bins = 20

# Define the localised mutual information function
def localise_mutual_info(node_mi_values):
    localised_mi = [node_mi_values[0]]
    for i in range(1, len(node_mi_values) - 1):
        local_mi = (node_mi_values[i - 1] + node_mi_values[i] + node_mi_values[i + 1]) / 3
        localised_mi.append(local_mi)
    localised_mi.append(node_mi_values[-1])
    return localised_mi

# Define the total number of videos
total_videos = data.shape[0]

# Create an empty array to store average localised mutual information values per node across the 27-node spatial 2D graph
average_mi_per_node_across_videos = np.zeros((27,))

# Loop through all videos
# Generated by OpenAI's ChatGPT
for video_index in range(total_videos):
    video_data = data[video_index]

    # Create an array to store mutual information values for each node
    node_mi_values = []

    # Loop through all nodes
    for node in range(video_data.shape[2]):  # Assuming the third dimension contains the nodes
        # Create an array to store localised mutual information values for each frame within the node
        local_mi_values = []

        # Loop through all frames and calculate mutual information
        for i in range(video_data.shape[1]):  # Include all frames
            if i == 0:
                continue  # Skip the first frame since there's no previous frame

            # Extract the data for the i-th and (i-1)-th frames for the current node
            frame_i = video_data[:, i, node, 0]
            frame_im1 = video_data[:, i - 1, node, 0]

            # Reshape the data to 1D arrays (flatten them)
            flat_frame_i = frame_i
            flat_frame_im1 = frame_im1

            # Create histograms for the i-th and (i-1)-th frames
            hist_i, _ = np.histogram(flat_frame_i, bins=num_bins, density=True)
            hist_im1, _ = np.histogram(flat_frame_im1, bins=num_bins, density=True)

            # Calculate the mutual information between the histograms
            mi = mutual_info_score(None, None, contingency=np.histogram2d(hist_i, hist_im1)[0])

            # Append the mutual information value to the array for the current frame
            local_mi_values.append(mi)

        # Calculate the localised mutual information for the current node
        local_mi_values = localise_mutual_info(local_mi_values)

        # Append the array of localised mutual information values for the current node
        node_mi_values.append(local_mi_values)

    # Calculate the average localised mutual information value for each node
    average_local_mi_values = np.mean(node_mi_values, axis=1)

    # Update the array of average mutual information values across videos
    average_mi_per_node_across_videos += average_local_mi_values

# Calculate the final average mutual information values for each node across all videos
final_average_mi_values = average_mi_per_node_across_videos / total_videos
print(final_average_mi_values)
